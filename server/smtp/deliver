#!/usr/bin/perl -Tw
# Takes an email on stdin and build a file from each mime part.
# Store the file and upload its headers to mdird.
#
# (C) Benjamin Elijah Griffin	20 July 2001
# Reworked for SCAMBIO, Feb 2008

use strict;
use File::Path;         # for a portable `mkdir -p`: mkpath()
use POSIX qw( strftime );
use MIME::Base64;
use MIME::QuotedPrint;

use vars qw( $dir $lock $level $message %levelpart
             %default $REmimeval $REextension $REfilename $REpath $REtmpldir );

%default = (
  # When no content-type specified, consider it this.
  contenttype        => "text/plain",
  # Prefixes of output files with internally generated names
  headerprefix       => "headers",
  mimepreambleprefix => "mimepreamble",
  mimeepilogueprefix => "mimeepilogue",
  partprefix         => "part",
  # Print all parts? Headers, mime preamble and epilogue, part headers...
  printall         => 1,
  # Recurse into message/* parts?
  messagerecurse   => 0,
  # If recursing the MIME structure, add extra indentation per recurse level
  indentperlevel   => '  ',
  # Maximum length for a filename (including extension)
  filenamelength   => 80,
  # Print warnings?
  showwarnings     => 1,
  # Suppress printing filenames?
  quiet            => 0,
);

# Match and capture in $1 a filename extension (with the '.').
$REextension = qr/(\.[a-z0-9]{1,7})$/i;
# Match and capture in $1 a filename (ignoring length).
$REfilename  = qr/^([a-z\d][a-z\d\._-]*)$/i;
# Untaint command line path names
$REpath      = qr:^([^<>'"&;!`\$]+)$:;
$REtmpldir   = qr:^(/[^<>'"&;!`\$]+)$:;

# For "foo='bar'" in headers, match the equals and the value,
# capturing the value ($+ will be used to grab the value).
$REmimeval   = qr{= (?:
		      "([^"]+)"		# double quoted
		     |'([^']+)'		# single quoted
		     |(\S+)		# missing or broken quotes
		    )
		    (?:
		      \s
		     |;
		     |$
		    )
	        }x;

# Prototypes {
sub THEEND ($);
sub dosighandlers();
sub expandcreate($);
sub process($$);
sub fileinfo($$);
sub pickname($$;$);
sub pickext($);
sub checklen($);
sub cleanse($$$);
sub dumpheaders($$$);
sub dumpbody($$$$);
sub mkextmap();
sub mylock($);
sub myunlock($);
# } end prototypes

# Initialization {
$level = 0;
mkextmap();
# } end inits

# Main functionality {
dosighandlers();
undef($/);
$message = <>;
process('.', \$message);
exit(0);
# } main functionality

# FUNCTIONS FOLLOW

# The main, recursive, function to extract data from a MIME message.
sub process($$) {
	my $cwd = shift;
	my $messref = shift;
	my ( $boundary, $type, $filename, $encoding, $header, @headers, $line, $outfile, $name );
	$line = 1;
	$encoding = 'none';

	while($$messref =~ s/\A([^: \t\n]+.+|[ \t]+.*)\n//o) {
		$header = $1;
		if ($header =~ /^\s/o) {
			$headers[-1] .= "\n$header";
		} else {
			push(@headers, $header);
		}
		$line ++;
	} # while finding headers

	if($$messref =~ s/\A\n//o) {
		# good, good.
		$line ++;
	} else {
		warn "$0: level $level, header parse error line $line not blank.\n";
	}

	for $header (@headers) {
		if ($header =~ /^message-id:(.+)/iso) {
			my $msgid = $1;
			chomp($msgid);
			if ($msgid =~ /\<(.+)\>/so) {
				$msgid = $1;
			}
			$msgid =~ tr[@\.][/];
			my @msgids = split(/\//, $msgid);
			while ($#msgids > 3) {	# max level of dir
				shift @msgids;
			}
			$cwd = "$cwd/".join("/", reverse @msgids);
		} elsif ($header =~ /^content-type:(.+)/iso) {
			my $rawtype = $1;
			if ($rawtype =~ s:^\s*([a-z0-9.-]+/[a-z0-9.-]+)::io) {
				$type = lc($1);
			} else {
				$type = $default{contenttype};
				warn "$0: level $level, can't parse content-type, using default\n";
			}
			if ($type =~ m:^multipart/:o) {
				if($rawtype =~ s{ (?:\s*;\s*)? \b boundary $REmimeval }{}xi) {
					$boundary = $+;
				} else {
					warn "$0: level $level, can't find boundary\n";
				}
			} elsif ($rawtype =~ s{ (?:\s*;\s*)? \b (?:file)?name $REmimeval }{}xi) {
				# Allow Content-Disposition: attachment; name=foo to override
				if (!defined($filename)) {
					$filename = $+;
				}
			}
		} elsif ($header =~ /^content-disposition:(.+)/iso) {
			my $hval = $1;
			if ($hval =~ s{ (?:\s*;\s*)? \b (?:file)?name $REmimeval }{}xi) {
				$filename = $+;
			}
		} elsif ($header =~ /^content-transfer-encoding:\s* (base64|quoted-print[ai]ble)/ixo) {
			# Other possible values include 7bit, 8bit; they get processed
			# the same as the default 'none' though.
			# "base64" or "quoted"
			$encoding = lc(substr($1, 0, 6));
		}
	} # for $header (@headers)

	if(!defined($type)) {
		$type = $default{contenttype};
		warn "$0: level $level, can't find content-type, using default\n";
	}

	if (!defined($filename)) {
		$filename = pickname($level, $type);
	} else {
		$filename = cleanse($level, $filename, $type);
	}

	if (!defined($boundary)) {
		$outfile = dumpbody($encoding, $cwd, $filename, $messref);
		fileinfo($level, $outfile);
		if($default{messagerecurse} and $type =~ /^message/o) {
			$level ++;
			process($cwd, $messref);
			$level --;
		}
	} else {
		my $part = '';
		my $mline;

		# Find first boundary
		while($$messref =~ s/\A(.*\n)//o) {
			$mline = $1;
			if($mline =~ /^-*\Q$boundary\E-*\s*$/) {
				if (length($part)) {
#					if ($default{printall}) { 
#						$name = pickname($level, 'preamble', $default{mimepreambleprefix});
#						$outfile = dumpbody('none', $cwd, $name, \$part);
#						fileinfo($level, $outfile);
#					}
					$part = '';
				}
				last;
			} else {
				$part .= $mline;
			}
		} # while messref (first boundary)

		# Find additional boundaries
		while($$messref =~ s/\A(.*\n)//o) {
			$line = $1;
			if($line =~ /^-*\Q$boundary\E-*\s*$/) {
				if (length($part)) {
					process($cwd, \$part);
					$part = '';
				}
			} else {
				$part .= $line;
			}
		} # while messref (additional boundaries)

		if (length($part)) {
#			if ($default{printall}) { 
#				$name = pickname($level, 'epilogue', $default{mimeepilogueprefix});
#				$outfile = dumpbody('none', $cwd, $name, \$part);
#				fileinfo($level, $outfile);
#			}
		}

	} # if $boundary

	if ($default{printall}) { 
		$outfile = dumpheaders($cwd, ".header.$filename", \@headers);
		fileinfo($level, $outfile);
	}
} # end &process

# Expand a directory template, build directory path for it, and
# return the directory created. Dies upon failure.
sub expandcreate($) {
	my $tmpl = shift;
	my $basedir;
	my $dir;
	my $num = 0;

	$basedir = $tmpl;
	$basedir =~ s:/[^/]*[%].*::;
	$tmpl =~ s:/+:/:g;
	$tmpl =~ s:%#:\cA:g;
	$tmpl = strftime($tmpl, localtime);
	$dir = $tmpl;
	if ($dir =~ /\cA/) {
		$lock = "$basedir/.lock$>";
		mylock($lock);
		while ($dir =~ /\cA/) {
			$num ++;
			$dir =~ s/\cA/$num/g;
			if (-d $dir or -f $dir) {
				$dir = $tmpl;
				next;
			}
			mkpath([$dir],0,0777);
			myunlock($lock);
			$lock = undef;
		}
	} else {
		mkpath([$dir],0,0777);
	}
	if (!-d $dir) {
		die "$0: Can't create directory $dir\n";
	}
	return($dir);
} # end &expandcreate


# Signal handler for fatal signals.
sub THEEND ($) {
	my $sig = (shift or '(unknown)');
	if(defined($lock) and (-f $lock)) {
		myunlock($lock);
	}
	if ($sig !~ /^[A-Z\d]+$/) {
		# __DIE__ or the like
		$sig =~ s/\s+/ /g;
		die "$0: Got DIE: '$sig' ... exiting\n";
	} else {
		die "$0: Got SIG$sig ... exiting\n";
	}
} # end &THEEND 

# Signal handler for warnings.
sub WARN ($) {
	my $warning = (shift or '(unknown)');
	if ($default{showwarnings}) {
		print STDERR $warning;
	}
} # end &WARN 

# Installs the signal handlers.
sub dosighandlers() {
	$SIG{INT}      = 'main::THEEND';	# <ctrl-c>
	$SIG{QUIT}     = 'main::THEEND';	# <ctrl-\>
	$SIG{TERM}     = 'main::THEEND';	# plain 'kill'
	$SIG{HUP}      = 'main::THEEND';	# hang-up signal
	$SIG{__DIE__}  = 'main::THEEND';	# die()
	$SIG{__WARN__} = 'main::WARN';	# warn()
} # end &dosighandlers


# For a MIME type, try to find a suitable filename extension.
# Returns the extension (with the dot) or an empty string.
sub pickext($) {
	my $type = lc(shift);
	my $ext;
	if(defined($ext = $default{ext}{$type})) {
		return ".$ext";
	}
	# Change "text/x-foobar" to "text/*"
	$type =~ s:/.*:/*:;
	if(defined($ext = $default{ext}{$type})) {
		return ".$ext";
	}
	if(defined($ext = $default{ext}{default})) {
		return ".$ext";
	}
	return "";
} # end &pickext


# Attempts to sanitize (and untaint) a filename. Generates a new
# filename if it cannot. Returns the clean filename.
sub cleanse($$$) {
	my $level = shift;
	my $input = shift;
	my $type  = shift;

	# only simple names ok as-is
	if ($input =~ /$REfilename/i) {
		return(checklen($1)); # untaint
	}
	$input =~ s:.*/\.*([^/]*):$1:;
	$input =~ s:[^a-z\d\._ -]+::ig;
	$input =~ s:\s+:-:g;
	if ($input =~ /$REfilename/i) {
		return(checklen($1)); # untaint
	}
	return pickname($level, $type);
} # end &cleanse

# Prints out a filename, with indentation.
sub fileinfo ($$) {
	my $level = shift;
	my $name = shift;

	if ($default{quiet} or !defined($name)) {
		return;
	}
	$name =~ s://+:/:g;
	if (defined($default{indentperlevel})) {
		$level = $default{indentperlevel} x $level;
	}
	print "\t$level$name\n";
} # end &fileinfo 

# Generates and returns a filename (without directory). The mime
# type is used to try to find a suitable extension.
sub pickname ($$;$) {
	my $level = shift;
	my $type = shift;
	my $pre  = (shift || $default{partprefix});

	my $seq = ($levelpart{$level} || 0);
	$levelpart{$level} = $seq + 1;
	return "$pre-$$-${level}_$seq" . pickext($type);
} # end &pickname 

# Returns a version of the provided filename that is no longer
# than the maximum length. The filename is shortened from the
# end, with an attempt to preserve the extension.
sub checklen($) {
	my $name = shift;

	if(length($name) > $default{filenamelength}) {
		my $ext = '';
		if ($name =~ s/$REextension//i) {
			$ext = $1;
		}
		$name = substr($name, 0, $default{filenamelength} - length($ext)) . $ext;
	}
	return $name;
} # end &checklen


# Prints a body or attachment part, decoding if needed, to a specified
# file. Returns 'undef' for error, and the filename on success.
sub dumpbody($$$$) {
	my $enc   = shift;
	my $dir   = shift;
	my $fname = shift;
	my $mref  = shift;

	$dir = &expandcreate($dir);
	if (!open(BODY, ">$dir/$fname")) {
		warn "$0: can't open $fname: $!\n";
		return undef;
	}
	if ($enc eq 'none') {
		print BODY $$mref;
	} elsif ($enc eq 'base64') {
		print BODY decode_base64($$mref);
	} elsif ($enc eq 'quoted') {
		print BODY decode_qp($$mref);
	} else {
		warn "$0: What encoding is $enc?\n";
		print BODY $$mref;
	}
	close BODY;
	return $fname;
} # end &dumpbody

# Prints the headers to a automatically named file.
# Returns 'undef' for error, and the filename on success.
sub dumpheaders($$$) {
	my $dir   = shift;
	my $fname = shift;
	my $hdref = shift;
	local $,;

	$dir = &expandcreate($dir);
	$, = "\n";
	if(!open(HEAD, "> $dir/$fname")) {
		warn "$0: can't open $fname: $!\n";
		return undef;
	}
	print HEAD @$hdref;
	print HEAD "\n\n";
	close HEAD;
	return $fname;
} # end &dumpheaders


# Abstract the unlocking, so code only needs to be changed in one place.
sub myunlock($) {
	my $lockfile = shift;
	lock($lockfile);
} # end &myunlock

# Abstract the locking, so code only needs to be changed in one place.
sub mylock($) {
	my $lockfile = shift;
	my $basedir  = undef;
	unlock($lockfile);
} # end &mylock

# A default set of types to extensions, here rather than where
# other defaults are set since these will probably be edited less
# and are rather unsightly.
sub mkextmap() {
  $default{ext} = {
    # Used internally
    "default"                       => "seg",
    "preamble"                      => "txt",
    "epilogue"                      => "txt",
    # Regular content-types
    "text/x-vcard"                  => "vcf",
    "text/plain"                    => "txt",
    "txt/plain"                     => "txt",	# typo version
    "text/html"                     => "html",
    "text/sgml"                     => "sgml",
    "text/css"                      => "css",
    "text/xml"                      => "xml",
    "text/richtext"                 => "rtx",
    "text/calandar"                 => "ics",	# outlook specific?
    "text/rtf"                      => "rtf",	# might not be correct type
    "text/tab-separated-values"     => "tsv",
    "text/tab-seperated-values"     => "tsv",	# typo version
    "text/*"                        => "txt",
    "audio/x-aiff"                  => "aiff",
    "audio/x-wav"                   => "wav",
    "audio/x-pn-realaudio"          => "rm",
    "audio/x-realaudio"             => "ra",
    "audio/basic"                   => "au",
    "audio/mpeg"                    => "mp3",
    "audio/midi"                    => "mid",
    "audio/*"                       => "audio",
    "application/x-stuffit"         => "sit",
    "application/x-compress"        => "Z",
    "application/x-gzip"            => "gz",
    "application/x-cpio"            => "cpio",
    "application/x-gunzip"          => "gz",
    "application/x-bzip2"           => "bz2",
    "application/x-tar"             => "tar",
    "application/x-gtar"            => "tar",
    "application/x-shar"            => "shar",
    "application/x-tar-gz"          => "tgz",
    "application/x-zip-compressed"  => "zip",
    "application/x-ar"              => "a",
    "application/x-shockwave-flash" => "swf",
    "application/x-dvi"             => "dvi",
    "application/x-sh"              => "sh",
    "application/x-perl"            => "pl",
    "application/x-tcl"             => "tcl",
    "application/x-javascript"      => "js",
    "application/x-tex"             => "tex",
    "application/x-texinfo"         => "texinfo",
    "application/x-latex"           => "latex",
    "application/x-troff"           => "tr",
    "application/x-troff-man"       => "man",
    "application/x-troff-ms"        => "ms",
    "application/x-troff-me"        => "me",
    "application/x-patch"           => "patch",
    "application/pgp-signature"     => "sig",
    "application/andrew-inset"      => "ez",
    "application/postscript"        => "ps",
    "application/mac-binhex40"      => "hqx",
    "application/mac-compactpro"    => "cpt",
    "application/pdf"               => "pdf",
    "application/rtf"               => "rtf",	# might not be correct type
    "application/smil"              => "smil",
    "application/msword"            => "doc",
    "application/vnd.msword"        => "doc",	# not correct
    "application/vnd.ms-word"       => "doc",	# not correct
    "application/msexcel"           => "xls",	# not correct
    "application/vnd.msexcel"       => "xls",	# not correct
    "application/vnd.ms-excel"      => "xls",
    "application/vnd.ms-powerpoint" => "ppt",
    "application/*"                 => "data",
    "video/x-msvideo"               => "avi",
    "video/x-shockwave-flash"       => "swf",	# correctly application/...
    "video/mpeg"                    => "mpg",
    "video/quicktime"               => "mov",
    "video/*"                       => "video",
    "image/x-xbm"                   => "xpm",
    "image/x-portable-bitmap"       => "pbm",
    "image/x-portable-greymap"      => "pgm",
    "image/x-portable-pixmap"       => "ppm",
    "image/x-xbitmap"               => "xbm",
    "image/x-xpixmap"               => "xpm",
    "image/x-xwindowdump"           => "xwd",
    "image/x-ico"                   => "ico",
    "image/x-png"                   => "png",
    "image/png"                     => "png",
    "image/tiff"                    => "tiff",
    "image/bmp"                     => "bmp",
    "image/gif"                     => "gif",
    "image/jpeg"                    => "jpg",
    "image/pjpeg"                   => "jpg",
    "image/*"                       => "image",
    "model/vrml"                    => "vrml",
    "message/rfc822"                => "mail",
    "message/news"                  => "news",
    "message/partial"               => "segment",
    "message/*"                     => "message",
  };
} # end &mkextmap

