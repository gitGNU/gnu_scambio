démon MDIR
==========

Privilégier une approche complètement assynchrone par évènements.  Utiliser 
libpth qui fait ça très bien et est très portable.

Modules de la lib générale (libcommons)
---------------------------------------

Communication :
~~~~~~~~~~~~~~~

- connect(flux/messages, adresse)
- disconnect
- receive
- send
- serve(flux/message, address, thread)

Conserver l'abstraction des adresses (par exemple, ce serait bien de pouvoir 
mettre un fichier).

connect renvoie un fildesc.

Système :
~~~~~~~~~

- configuration (envvar sous unix) ;

- commandes (console) ;
  L'idée ici est double : avoir une console de configuration/administration 
(avec une commande pour ouvrir le service pour éviter que les requetes ne 
soient traitées sans configuration), et pouvoir interpréter les ordres 
provenant des clients de mdird.

- démonisation ;
  Mise en background du process

- logs ;

Journal du mdir (libjnl)
------------------------

On raisone répertoire par répertoire.

Chaque répertoire contient des journaux, chacun couvrant une plage de numéro 
de versions. La première version du premier journal est la version la plus 
ancienne à laquelle on puisse accéder.  Le dernier numéro de version du 
dernier journal est le numéro de version courant du répertoire.  Les journaux 
servent pour générer un diff depuis Vi, suivant l'algorithme :

- si Vi est antérieur à la première version du plus vieux journal on considère 
qu'on nous demande ce numéro à la place (ceci permet aux nouveaux clients de 
demander le diff depuis 0, sans connaitre le premier numéro de version) ;
- si Vi est postérieur à la version finale du plus récent journal, le diff est 
terminé.
- ouvrir le journal contenant Vi.
- on le lit jusqu'à la version Vi.
- on écrit tout son contenu, ce qui nous amène à la version Vf.
- on recommance, avec Vi=Vf+1 (la condition d'arrêt a déjà été donnée).

Lorsqu'un répertoire ne contient pas de journal, il doit être vide.

On voit qu'il est intéressant de ne pas avoir trop de versions par journal car 
ainsi on n'est pas obligé de parcourir pour rien trop de patchs au début, sauf 
pour le premier journal qui sert aux nouveaux clients à ce mettre à jour 
initialement.

L'algorithme donné plus haut est simpliste : de nombreuses modifications vont 
se contredire (ajout suivi de suppression, suivi d'ajout...). Il serait utile 
d'optimiser les journaux (parcourir les patchs à la recherche de 
contre-ordres) ; ceci peut-être réalisé par un outils externe puisque les 
journeaux, une fois bouclés, sont en lecture seule (un journal est bouclé 
lorsqu'il est suivi chronologiquement d'un autre).

La taille des journaux non optimisés devrait être configurable.
De plus, les premiers journaux devraient être plus gros. En fait, les tailles 
devraient être décroissantes (l'optimiseur de journaux peut aussi changer les 
tailles - d'ailleurs il n'est pas interdit que plusieurs journaux se 
chevauchent, ce qui facilite son travail (il peut ne réécrire qu'un seul 
journal à la fois).

Modèle du protocole
~~~~~~~~~~~~~~~~~~~

Les contraintes à respecter sont :

- il faut pouvoir envoyer des notifications ou des patchs complets aux clients 
  en temps réel (push) ;
- il ne faut pas maintenir une connection TCP en permanence pour ne pas obligé 
  le kernel à maintenir un contexte par client ;
- il faut que la communication soit le plus efficace possible - critère 
  particulièrement important pour la mobilité ;

Pour les notifications, deux approches sont possibles :

- soit on utilie un second canal de communication pour les notifications, et 
  dans ce cas les notifications ne contiennent que les nom de répertoires à 
ressynchroniser ;
- soit on utilise le même canal que celui de la synchronisation, et dans ce 
  cas la synchronisation est simplement permanente ;

La première solution est moins élégante, pose le problème de l'accessibilité 
du client pour le serveur, et est moins efficace. La seconde à les qualités 
inverses, mais nous force à établir un dialogue UDP entre le client et le 
serveur.

Dans ce second scénario, on procèderait comme suit :

- le client se "connecte" en UDP, et envoit des commandes pour ajouter ou 
  supprimer des répertoires de la liste des répertoires qu'il souhaite 
synchroniser accompagné du dernier numéro de version connu (plusieurs 
commandes par paquets mais gare au MTU).

- le serveur spawn un client pour cette socket, dont l'environnement contient 
  tous ces détails. Il ajoute ce listener à chaque répertoire signalé, et 
répond OK ou pas à ces demandes de synchronisation (encore une fois, un seul 
paquet suffit).

- Le serveur envoie alors un flux de commandes de synchronisation (plusieurs 
  commandes par paquets éventuellement).

- Le numéro de version de répertoire d'un client est connu par le serveur, 
  donc celui-ci le met dans la commande qui patch cette version dans la 
version suivante (les numéros de versions ne sont pas obligés de ce suivre 
(*)) de telle sorte que le client puisse détecter une perte de paquet et la 
signaler au serveur en se réinscrivant comme listener de ce répertoire avec le 
numéro de version connu.

(*) du fait de l'optimisation des journaux, et parceque ca évite à un serveur 
qui démarre de rechercher les derniers numéros.

- lorsqu'un nouveau message arrive dans un répertoire écouté par un client, 
  son thread (bloqué en lecture sur la socket ou sur un évènement consacré) se 
réveille et lui envoit le patch.

- le client peut envoyer ses propres patchs au serveur sauf qu'alors la 
  version n'est pas renseignée (il redownloadera ce patch plus tard dans le 
cadre de la synchronisation s'il lit ce répertoire). Il a besoin de recevoir 
une confirmation du serveur. C'est donc bien un type de message spécial.

Il n'est pas interdit par ailleurs d'implémenter aussi un listener TCP, plus 
facile pour les tests, mais qui ne permet pas au client de rester connecté 
trop longtemps.

On a donc comme requètes :

- PUT/REM/CLASS suivit d'un répertoire et d'un header, auxquels le serveur 
  répond par une ligne avec status ;
- (UN)SUBSCRIBE suivit d'un répertoire et de la dernière version connue, 
auxquels le serveur répond encore par une ligne avec status ;

Et des messages de synchronisation à l'initiative du serveur :

- des patchs suivis du nom de répertoire, de l'ancienne version (-1 si 
  absente) et de la nouvelle, puis d'un header. Le client ne répond pas 
autrement qu'en détectant les erreurs de transmission comme vu ci-dessus.

Et bien sur les commandes de politesse : QUIT/AUTH/etc...

Commandes du protocole
----------------------

Le mdir gère la présence de fichiers, dont il ne connait que les headers 
(l'url étant une méta-donnée facultative mais généralement présente qui peu t 
permettre de distinguer des fichiers sinon différetns ou de récupérer un 
contenu), dans des répertoires. Il permet à ses clients d'ajouter des fichiers 
à des endroits précis oubien de les classer à partir d'un endroit précis 
(généralement à la racine) ou de les retirer (rappel : on retire les headers, 
pas le contenu, qui est toujours disponible dans le msgstore avec ses 
headers).

Les commandes entre client et serveur sont assynchrones et incenssibles à la 
casse (sauf pour leurs éventuels arguments). Le protocole est assymétrique : 
le client pose les questions et le serveur y répond. Le serveur mdird ne peut 
se transformer en client. Pour la synchronisation entre différents serveurs 
mdird, on utilisera un autre protocoles (copie des journaux). Cela simplifie 
_beaucoup_.

Les requètes sont donc préfixées d'un numéro unique servant à les associer 
avec leur réponse (par exemple une séquence mais ce n'est pas obligé). Ce 
numéro ne doit pas excéder 64 bits, ce qui est amplement suffisant pour une 
session. Les réponse commencent par ce numéro, puis le nom de la commande, 
puis un status. Le nom de la commande est utile dans le cas où un client 
voudrait "skipper" une réponse sans le souvenir de ce qu'il avait demandé.

Les status sont inspirés du HTTP (2XX pour OK, 5XX pour erreurs...)

Les commandes sont les suivantes :

SUB
~~~

Arguments : *répertoire* ainsi que le dernier numéro de *version* connu.

UNSUB
~~~~~

Arguments : *répertoire* (en toutes lettres)

PUT
~~~

Arguments : *répertoire* puis les headers terminés par une ligne ne contenant 
que '%%'.

Cela place de fichier dans le répertoire.

CLASS
~~~~~

Semblable à PUT, mais le fichier est soumis au classement automatique.

REM
~~~

Format semblable à PUT, mais signifiant au contraire que tout fichier 
possédant ces headers doit être retiré.

PATCH
~~~~~

Jusqu'ici toutes les commandes étaient des requètes : à l'initiative du client 
et attendant une réponse du serveur.  Cette commande en revanche provient du 
serveur, ne tient pas sur une ligne car elle est suivit d'un header, et reste 
sans réponse.

Arguments : *répertoire* puis *ancienne version*, suivit du contenu du journal 
c'et à dire '%+/-' et *nouvelle version*, suivit d'un header terminé par '%%'.  
On a donc bien l'ancienne version (celle attendue par le client ou la dernière 
qu'on lui a envoyé) et la nouvelle.

Si l'action est '%+', un fichier représenté par ce header doit être ajouté 
s'il n'existe pas déjà et si c'est '%-' tout fichier possédant ce header devra 
être effacé (les headers sont donc uniques par répertoire, par construction).  
La dernière commande reçue et comprise par le client lui permet d'accéder à la 
version indiquée. C'est plus verbeux qu'une seule version figurant à la fin de 
la liste (ou en début) mais cela peut permettre au client de se rattraper 
partiellement en cas de transfert incomplet et c'est plus simple pour le 
serveur qui ne fait que recopier son journal.

On utilise '%+', '%-' et '%%' pour minimiser le risque d'avoir un nom de 
champs commencant par le délimiteur (ce qui est interdit) et faciliter le 
dialogue manuel avec un mdird. Par ailleurs, et pour cette dernière raison, on 
ignorera toujours les espaces en fin de ligne.

Journal encore plus simple
--------------------------

Deux types de fichiers par répertoire :
des fichiers %020lld.log et %020lld.idx.
Les fichiers de log contiennent les patches ("%+ version\na: b\n..."),
et les fichiers d'index contiennent un tableau d'offsets dans le fichier de 
log, de telle sorte que l'offset du patch conduisant à la version V se trouve 
dans idx[V].

Il faut toutefois locker le répertoire en écriture pour pouvoir facilement 
mettre à jour en append les deux fichiers, log et idx.

L'API s'en trouve grandement simplifiée, car on n'a pas besoin alors de lire 
les patchs ligne à ligne, etc : on connait fassilement leur position et la 
position du suivant, et donc aussi leur taille.

On pourrait même compresser (les log et les transferts réseau) mais pas 
pendant le débugage.

Pb : lorsqu'un nouveau client fait sa synchro initiale, il ne doit pas 
récupérer l'historique complet. Pour cela, il faut nettoyer les log lorsqu'il 
sont vieux, en les rejouant virtuellement et en écrivant à la fin des patchs 
pour créer ceux qui restent. L'ennuis c'est qu'on introduit des gaps dans les 
numéros de version, ce qui est génant (par ex pour déterminer les tailles).  
C'est moins génant si on n'autorise ces gaps qu'entre deux fichiers.


// vim: syntax=asciidoc
