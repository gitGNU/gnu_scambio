Sharing, Control and Access of Messages through Basic Inputs/Outputs (SCAMBIO)
==============================================================================

Gêner l'emmergeance de nouveaux protocoles réseaux propriétaires dans le 
domaine de la messagerie et du group-ware, en proposant une alternative libre 
et facilement extensible pour la communication inter-individuelle/groupes.

Utiliser ou même améliorer les solutions existantes (principalement Kolab) 
n'est suffisant, car ces solutions ne sont pas facilement extensibles. Mail, 
calendrier et contacts unifié, voilà ce qui semble leur principal objectif.  
Pour l'atteindre, elles se contentent donc d'implémenter la tuyauterie 
manquante aux clients et serveurs déjà existants.

Si l'on ne voulait pas faire de compromis avec les programmes existants, il 
semble pourtant qu'il y aurait une solution bien plus simple. C'est cette 
nouvelle approche que l'on se propose d'essayer.

C'est au niveau des clients, dans la "boucle locale" des protocoles, que se 
situent les enjeux. Le plus important progrès possible est d'unifier et de 
simplifier cette "boucle locale" pour permettre d'améliorer et d'enrichir 
l'experience utilisateur. Un seul client doit permettre de recouper toutes les 
formes d'échanges. Toutes les suites de programmes de messagerie (par exemple 
les interfaces utilisateurs des gadgets mobiles) s'evertuent à donner 
l'illusion d'unité là où règne le plus grand chaos.

UNIX a, en son temps, radicalement amélioré les systèmes d'exploitations 
d'alors en se basant sur ces deux principes :

- aucune structure ne doit être imposée aux fichiers ;
- tout est assimilable à un fichier.

Notre solution tente une simplification similaire :

- les destinataires ne sont liés ni à une machine, ni à une personne ;
- aucune structure ne doit être imposée aux communications ;
- toute communication est un fichier immutable.

Le premier principe comporte deux volets, dont le premier est désormais bien 
établit : tout document échangé, tout message destiné à être conservé, ne doit 
pas être addressé à la machine physique utilisé à un moment donné par le 
destinataire, mais à un serveur constant qui est consulté par l'utilisateur 
depuis la machine qu'il utilise à un moment donné. Ce que nous appelons 
"boucle locale" consiste justement en cette consultation, et recouvre par 
exemple l'usage que l'on fait habituellement des protocoles de consultation 
d'email POP et IMAP ou des protocoles de partage de fichiers samba et NFS.

Poser que les destinataires ne sont pas nécessairement des personnes relève de 
l'observation : on addresse des emails à des groupes plus souvent qu'à des 
individus. Plutôt que de faire de la communication entre deux individus la 
norme et la communication à plus de deux individus un contournement de la 
norme, nous préférons poser au contraire que la boucle locale doit permettre 
d'embler à plusieurs utilisateur de partager les communications reçues 
(supporter les communications avec plusieurs _expéditeurs_ semble par contre 
inutile).

Le second principe découle d'une observation : tout protocole de communication 
est utilisé pour transporter autre chose que ce qui avait été prévu au départ, 
conduisant à utiliser des contournements parfois inélégants, voire à s'écarter 
des spécifications, ce qui affaiblit l'inter-opérabilité (et les 
performances). Pensons aux monstrueux encodages des emails et aux formes 
variées de violation du format des entêtes.

Nous préférons un protocole souple capable de stoquer et transporter n'importe 
quoi, quite à se reposer entièrement sur des programmes hôtes de la machine 
cliente pour interpreter le contenu reçu ou générer le contenu envoyé.

Le dernier principe, découlant des précédents, permet de simplifier à outrance 
le protocole reliant les utilisateurs à leur serveur de messagerie. En fait, 
il suffit plus ou moins de synchroniser les messages cachés localement avec 
les nouveaux messages présent sur le serveur ; synchronisation à sens unique 
et atomique, puisque les communications reçues ne sont pas modifiables par 
l'utilisateur destinataire.

Un bémol cependant : afin d'autoriser les communications en temps réels de 
gros contenus (par exemple de la visio conférence) les fichiers doivent être 
synchronisables par le client au fur et à mesure qu'ils sont reçus par le 
serveur, et de même dans l'autre sens, simultanément.

Par ailleurs, il peut exister un protocole de notification sur la boucle 
locale pour avertir en temps réel un utilisateur de l'arrivé d'un message (ce 
qui est bien sur nécessaire pour les communications en temps réel).


Existant
--------

Pourquoi pas Kolab ?
~~~~~~~~~~~~~~~~~~~~

Hétérogénéité, énormité. Met en relation des serveurs existants (LDAP, IMAP, 
SMTP, HTTP...) Difficile à faire évoluer vers des usages nouveaux. Difficile 
de faire communiquer les composants entre eux (LDAP semble le dénominateur 
commun).

Pourquoi pas IMAP pour le file-store ?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- mauvaise idée du namespace, rien pour distinguer message d'emplacement 
  (Similitudes MS-DOS plutôt qu'Unix).

- répartition des tâches client/serveur inapropriée : la recherche devrait 
  être sur le client (plus puissante, plus souple et plus simple), gestion 
inutile d'une liste de souscription.

- le protocole devrait être en UTF-8

- Manque un transport binaire plus rapide (adapté aux gros messages lourds 
  comme aux clients légers)

- LIST devrait systématiquement fournir un diff.

Mais en effet, pourquoi pas IMAP pour la lecture du file-store...

Fonctionnalitées existantes à reprendre
---------------------------------------

Calendrier
~~~~~~~~~~

Tout répertoire contenant des messages ou attachements de type vCal ou iCal 
sont des calendriers (ie, le client calendrier les représente d'une certaine 
couleur). Évidemment, puisqu'un même message se retrouve dans de nombreux 
répertoire cela fait beaucoup de calendrier. À l'utilisateur de choisir ceux 
qu'il veut afficher ou pas. C'est une richesse importante de pouvoir utiliser 
le même système de recherche et de rangement pour les évènements que pour les 
messages, et il ne faut pas s'en priver.

Contact
~~~~~~~

Tout répertoire contenant des messages ou attachements de type vCard, etc...
Penser aux clefs publiques.

Tasklist
~~~~~~~~

Tout répertoire contenant des messages ou attachements de type ... etc...

Notification d'absence
~~~~~~~~~~~~~~~~~~~~~~

Répertoire par répertoire (et récursivement) il est possible de positionner 
une réponse automatique. Par exemple, un utilisateur peut demander à ce que 
tous les mails arrivant dans user/INBOX (et pas par exemple dans 
user/subscriptions/) provoquent une réponse automatique (avec un timeout 
configurable).  Le serveur s'occupe de gérer la petite DB par folder. Les 
sous-répertoires héritent ou pas de cette propriété.

Ceci est implémenté directement au niveau du serveur, donc.

Envoi différé
~~~~~~~~~~~~~

Il s'agit d'un champ du header pris en compte par l'agent qui passe les 
messages de "a envoyer" vers "envoyé".

FreeBusy lists
~~~~~~~~~~~~~~

Utilité de ce truc ?

Droits
~~~~~~

Tout comme on réutilise le FS UNIX, réutiliser aussi le système de droits UNIX 
(avec utilisateurs et groupes), au maximum. Il faut qu'un répertoire puisse 
être lu et écrit par une liste de groupes, lu seulement par une autre liste de 
groupes, et invisible à tous les autres groupes (ACL unix ?)

Le droit en écriture mérite un développement : normalement, les protocoles 
SMPP, SMTP, etc, ont pour destinataires des utilisateurs, pas des groupes ni 
des boites. Les utilisateurs recoivent ensuite ces mails soit dans inbox, soit 
ailleurs s'ils ont des filtres automatiques (SIEVE, procmail, autre...).  Mais 
au sein des utilisateurs d'un même MDIR, on peut vouloir communiquer plus 
directement via ajout direct d'un message à un endroit précis (oubien on peut 
aussi créer des utilisateurs SMTP valides pour un groupe ou une boite, mais ca 
relève alors de l'administration du SMTP et/ou du MDA). C'est dans ce cas que 
l'on considère les droits en écriture.

UTF-8
~~~~~

Autoriser l'UTF-8 dans les sujets (et autres valeurs de champ de header au cas 
par cas).

Les noms de répertoire sont aussi en UTF-8.

Disponibilité de l'utilisateur (par client)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Chaque client renseigne le serveur sur la disponibilité de l'utilisateur. Les 
clients non connectés sont évidement automatiquement _absents_. autres status 
possibles : les classiques _away_ et _connected_.

Nouvelles fonctionnalitées
--------------------------

Boite "a envoyer" qui pousse un message dehors (SMTP)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Plus besoin d'envoyer deux fois le message. Feedback des tentatives de 
livraisons.

Templates de mails présents dans une boite (extention pour workflow)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Dans une boite on peut mettre une page web, un formulaire qui envoit un mail 
en utilisant l'interface (xul?) du lecteur de mail, etc...

Un mail se trouve dans plusieurs répertoires
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Remplace avantageusement les tags de google. Intégration naturelle avec le FS 
UNIX. En gros il faut qqchose de plus simple que SIEVE.

Pas besoin donc de l'extention vsearch, ni de cette de courrier qui stoque des 
recherches sur le serveur, et ca ne consomme ipresque aucune ressource chez le 
client ni chez le serveur (juste un lien dur).

Versionning
~~~~~~~~~~~

Equivalent NNTP du remplacement, sauf que l'ancienne version est toujours 
consultable. La synchronisation entre client et serveur (ou entre serveurs) 
peut se voir comme l'application d'un patch entre une ancienne version du FS 
(ou d'un seul répertoire) avec la dernière version.

Je ne suis pas certain que cette fonctionnalité soit très interressante : 
difficile à saisir (ajoute un niveau d'abstraction inhabituel dans les 
références), et ne faisant que forcer une certaine forme de classement (toutes 
les versions diffusées d'un document sont de toutes façon déjà présente 
quelquepart - il suffirait éventuellement d'un header particulier : 
"Supersedes: XXX").

Annotations
~~~~~~~~~~~

En fait, cela peut se faire via une réponse au groupe référencant le mail 
qu'on veut annoter. Le seul manque, c'est de pouvoir n'annoter qu'une partie 
du mail, mais c'est de toute facon illusoire (si on veut annoter un .doc 
contenu dans un message...). Le mieux que l'on puisse faire c'est étendre la 
notation du X-Ref pour ajouter un identifiant de pièce jointe.

Push de notifications
~~~~~~~~~~~~~~~~~~~~~

Si les utilisateurs sont connectés, oubien ils laissent un moyen de les 
contacter...

Messagerie instantannée
~~~~~~~~~~~~~~~~~~~~~~~

Garatuite avec le PUSH qui précède.

VoIP/Visio
~~~~~~~~~~

A condition que les fichiers puissent être écris, envoyés, reçus et lus 
simultanément. Possibilité de conserver une copie des échanges sur le serveur.

Synchronisation entre plusieurs serveurs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

N'est-ce que l'affaire de synchroniser le FS et le système de droits ?
Devrait être similaire à la synchronisation server->clients. Le transfert 
efficace des messages (ie binaire compressés) profiterait à tous.


Implémentation
--------------

Synchronisation
~~~~~~~~~~~~~~~

On appelle mdir la hiérarchie de répertoires contenant les liens vers les 
messages. Rien à voir avec les format mdir et mdir++.

Par ailleurs, il nous faut un identifiant de fichier unique, similaire à 
l'inode, pour que le client et le serveur ne transfèrent le même fichier 
qu'une seule fois plutôt qu'une fois par répertoire. Pour simplifier le 
serveur et le client, et pour permettre d'utiliser un système de fichier sans 
liens durs, les messages sont également stoqués dans une seconde arborescence, 
de manière unique cette fois ; et cette seconde arborescence sera appelée 
mstore. Ainsi par exemple un simple lookup de fichier dans le mstore permet au 
client de savoir s'il connait déjà tel message ou pas.

Le nom unique du fichier de message dans le mstore est appelé le MID. C'est 
l'URL sans le "http://", c'est à dire uniquement composé du hostname et du 
chemin.

Un mdir est comme un répertoire partagé, sauf que les fichiers sont atomiques 
c'est à dire manipulables uniquement globalement, qu'ils ont une structure 
fixe (au moins pour le contenant), et q'ils ne sont jamais modifiés. Cela 
simplifie beaucoup les choses. Par contre, ils ne sont pas forcément complets 
au moment de leur transfert (penser au streaming et autres fichiers "temps 
réel").

Les clients peuvent garder un cache de la structure et du listing des 
répertoires (ils sont même encouragé à le faire), mais peuvent demander à tout 
moment un listing ou un message (ou seulement une partie). Contrairement à un 
ls classique sous UNIX, ils ne voient pas les répertoires dans lesquels ils 
n'ont pas le droit de lire. De simples requètes HTTP suffisent à cela (voir 
séparément la question de l'authentification).

En règle générale, les répertoires sont versionnés et le ls ne renvoit qu'un 
diff entre une version antérieure N et la version courante (il est toujours 
possible de spécifier N=0).

Pour laisser au client le choix de ne pas suivre les évolutions d'une sous 
branche, et permettre de ne mettre à jour que ce qui est utile, il est plus 
simple de pouvoir ne demander que le diff d'un répertoire et pas de tout. Ce 
qui n'implique pas (mais n'exclut pas non plus) que le numéro de version soit 
propre au répertoire.  Chaque répertoire contient donc un journal des 
modifications entre deux versions, une modification pouvant être l'ajout ou la 
suppression d'un message ou d'un sous-répertoire.

De plus, chaque message est accompagné de ses métadonnées. Certaines sont 
implicites : identifiant (obligatoire), type (obligatoire pour les répertoire 
pour indiquer qu'il s'agit d'un répertoire justement), taille (optionel pour 
les messages en temps réel et les répertoires).  Ces méta données indiquent 
par exemple les mime-type, et tout autre champs du mail par exemple (mais 
reformaté pour simplifier l'encodage des header mail, trop compliqué : mettre 
sur une ligne, supprimer les commentaires). Ces méta-données pourraient être 
stoquées dans des répertoires ".meta" comme il existe des ".thumbs".

Les répertoires sont ajoutés et supprimés dans les répertoires comme des 
messages. Ils doivent donc aussi avoir des noms uniques (différent du nom 
public, la "short description"). Comme pour un message, la suppression d'un 
répertoire n'entraîne pas sa destruction irrévocable, puisqu'il est toujours 
présent dans une sorte d'Attic, prêt à ressurgir ailleurs.

Comme un message, un répertoire peut posseder des méta données explicites. Ses 
droits d'accès font par contre partis de ces méta données implicites.  De 
plus, chaque répertoire contient son journal et, pour simplifier, son numéro 
de version local (et probablement aussi, techniquement, ses locks).  Rien 
n'interdit, à ce niveau, de "monter" un même réportoire à plusieurs endroits.  
Comme toute méta donnée, les droits, nom public, etc, d'un répertoire sont des 
attribus du répertoire et pas du lien vers ce répertoire (de l'inode et pas de 
l'entrée de répertoire) ; impossible, donc, de "monter" un répertoire à divers 
endroits avec divers droits ni divers noms.

Remarque également que chaque répertoire contient ses sous-répertoires : 
impossible de déplacer ni de partager un répertoire sans également déplacer et 
partager ses sous-répertoires.

Les listings de répertoire listent des descriptions de messages/répertoires 
dont voici le format :

	action URL
	meta donnees
	...
	(ligne vide)

La liste se termine avec la réponse du serveur.

les méta données contiennent également les méta données ajoutées par le 
serveur : Source, Taille, Date

où :

- action vaut "+" pour un ajout, "-" pour un retrait de message ou répertoire.
- URL donne l'URL du fichier ou du répertoire ;
- source indique la provenance du fichier (eMail part, folder, ...) ;
- taille donne la taille en octets du fichier ou le nombre d'entrées du 
  répertoire ;
- date donne la date d'arrivé de ce fichier ou répertoire /dans ce folder/ ;

Aucune ligne ne peut commencer par "+" ou "-" sauf la ligne action. Les lignes 
non reconnues doivent être ignorées.

On remarque que les numéros de version du journal ne sont pas présents.

Les fichiers sont toujours triés par ordre de réception dans un listing, et 
pas par ordre de thread par exemple (pas par ordre lexicographique).

Note concernant les emails : Chaque PJ d'un email étant éclatée en autant de 
fichiers, il peut y avoir plusieurs messages par emails. C'est le prix à payer 
pour avoir un protocole de synchronisation généraliste et pouvoir accéder 
simplement aux parties d'un document multi-part.

Stockage des messages (serveur)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Le serveur n'est pas contraint de stoquer tous les messages dans un répertoire 
unique du mstore (ni même sur une seule machine).

Dans le cas des emails, le MID peut être par exemple composé de 
"email.domain.com" suivit du Message-Id découpé suivant les "." et les "@" 
puis inversé, le tout séparés par des "/".

L'URL permetant de downloader un message est absolue, afin de pouvoir répartir 
le mstore sur plusieurs machines. Les clients devraient pouvoir stoquer les 
messages dans leur cache de façon similaire (ie, l'arborescence des messages 
est "suffisamment balancé").

En plus de l'URL le serveur de mdir doit stoquer les meta données quelquepart 
(le client aussi). Par similitude avec les répertoires ".thumbnails" 
<<thumbs>>, on peut faire un répertoire ".meta" contenant ces données par 
messages, avec une lib chargée de les extraire, de les inventer lorsqu'elle 
n'y sont pas, et de les écrire. La standardisation des metadonnées est 
d'ailleurs avancée <<meta>>, mais je ne suis pas sur de vouloir suivre ce 
cours.

Le plus simple c'est que le serveur de mdir, privé conceptuellement d'un accès 
au mstore, stoque dans les répertoires du mdir des fichiers dont le contenu 
donne l'URL et les méta données (liens durs si stoqués dans plusieurs 
répertoires, car jamais modifié).

Stockage des folders (serveur)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Les folders utilisés pour classer les messages sont de vrais répertoires. Ils 
contiennent optionnellement un fichier de journal et un fichier de snapshot 
pour une version donnée. Si le journal n'existe pas, c'est que seul une 
resynchronisation totale du folder est possible. Si le snapshot n'existe pas, 
c'est que seul le journal est disponible. Si aucun des deux n'existent le 
folder est vide. Il peut y avoir plusieurs fichier de journal, chacun 
commencant à un numéro de version donné et conduisant à un autre numéro de 
version ; voir ceci comme une façon de parcourir plus rapidement les logs 
(permet de sauter jusqu'au numéro de version voulu). Par contre, seul le 
dernier snapshot est utile : il ne sert que pour les resynchronisations 
totales, que le journal vient compléter.

Lorsqu'on demande un listing depuis la version Vo, chercher le journal 
correspondant à ce numéro de version, et en extraire tous les patchs jusqu'à 
la version courante. Si un journal suffisament vieux n'est pas trouvé, alors 
repartir de la version 0 avec le snapshot et les journaux récents.

L'API permettant d'accéder aux journaux est la suivante :

jnl_start(version) -> renvoie un curseur où une erreur si le journal n'est pas 
trouvé.

jnl_next(cursor) -> renvoie le prochain patch ou EOF si c'est la fin.

Si jnl_start renvoie une erreur, utiliser le snapshot :

snapshot_open() -> renvoie un handler sur le snapshot. Tant que l'apli possède 
ce handler le snapshot reste valide (ie, c'est le fd d'un fichier).

snapshot_version(hd) -> renvoie le numéro de version du snapshot (ie. le 
numéro de version au moment du snapshot).

snapshot_content(hd) -> renvoie le contenu du snapshot. Ce contenu a la forme 
d'un diff normal, sauf que le numéro de version n'est pas présent (ce numéro 
propre à chaque patch qui de toute facon n'est pas communiqué au client).

snapshot_close(hd);

Puis enchainer avec jnl_start(snapshot_version(hd))...

Client
~~~~~~

Plutôt que de chercher un client intégré traitant tous les types de messages 
possibles, pourquoi ne pas faire un équivalent graphique de MH ? C'est à dire 
un browser de messages chargé de représenter la hiérarchie, de synchroniser 
les répertoires, de déplacer les messages, etc, mais qui ne connait des 
messages que leur header, et se reposant sur des programmes externes pour 
visualiser ou créer de nouveaux messages pour un type mime donné ?

Deux difficultés :

- les fichiers "temps-réel" qui impose à ce browser d'écrire alors le message 
  dans un fifo.

- certains messages n'ont de sens qu'avec les autres de la même catégorie : 
  par exemple le calendrier qui représente tous les vCal, par type, et les 
messages qui les référencent éventuellement (en tout cas, permet de lier 
dessus).

A la base, il y a donc le browser qui affiche la hiérarchie, gère une notion 
de répertoire courant, affiche la liste des messages, permet de les modifier, 
etc... Pour des raisons d'efficacité, et parceque les messages sont read-only, 
chaque programme externe peut travailler directement avec le fichier.  Ne pas 
commettre l'erreur d'intercaler encore une couche d'abstraction à ce niveau 
qui mimerait chichement le système de fichiers. Par contre il n'est pas 
interdit de fournir une bibliothèque pour parser les headers et autres 
informations additionnelles (qui ne sont pas forcément en lecture seule celles 
là - par exemple la liste des références vers un message donné -, mais qui 
sont gérables avec le FS - ajout des références en fin de fichier, création de 
nouveaux inodes...)

Pour le stockage des messages et folders, cela dépend du FS et de l'OS. Sous 
Unix, on privilégiera évidement les liens durs entre un cache de messages 
(identique au mstore du serveur, fonctionnant comme un cache pour conserver 
les vieux messages qui ne sont plus référencés par aucun folders), et le mdir 
(restreint en fonction des droits).

Il serait bon toutefois d'introduire dans cette arborescence une différence 
notable : plutôt que de lier en dur vers les fichiers on gagnerait à utiliser 
les noms "de fichier" qui peuvent être suggérés par le transports (par 
exemple, par le descripteur MIME des pièces jointes d'un email).  Deux 
manières de procéder :

- Le browser de fichier affiche simplement le "suggested name" des méta 
  données s'il est présent. L'ennuis c'est qu'on n'y comprend plus rien avec 
un explorateur de fichier ou un shell.

- On stoque les fichiers directement avec leurs suggested names dans le cache, 
  dans un répertoire du nom du MID, comme ceci l'unicité du cache est 
garantie. Par contre l'unicité dans le mdir peut poser problème.  On peut 
mettre un lien symbolique à la place du lien dur en cas de conflit, avec un 
numéro ajouté ?

Dans un premier temps la première solution est suffisante.


Envoi et Réception de messages
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

On appelle _connecteur_ un démon qui implémente le transport (la réception 
et/ou l'envoi) d'un type de message. On appelle _délégué_ un programme qui gère 
certains types de messages au niveau du logiciel client. Il peut y avoir 
plusieurs instances du même connecteur et plusieurs instances du même délégué 
qui tournent en même temps.

Un même utilisateur peut utiliser plusieurs clients. Chaque client tente de 
maintenir une connection au serveur pour les notifications. Le réglage de la 
"sensibilité" de cette connection (càd le niveau d'importance des 
notifications que l'on souhaite recevoir) est faite client par client, de 
manière que les clients légers ne reçoivent que les choses importante, et que 
les clients ne reçoivent que ce qu'ils savent traiter. Ce réglage est fait 
répertoire par répertoire (sachant que les sous-répertoires héritent de la 
configuration de notification d'un répertoire). En d'autres termes, chaque 
client demande au serveur d'être notifié de ce qui arrive à partir de tel ou 
tel répertoire, et de ne pas l'être (ce qui est le comportement par défaut, 
mais peut permettre d'annuler des sous-répertoires) dans tel et tel autres.

Des indications de présence adaptées aux connecteurs peuvent être déduites 
simplement à partir de l'activation ou non de notification sur les répertoires 
concernés (en simulant l'arrivée d'un message depuis le requérant et en 
regardant si une notification serait générée pour ce répertoire destination 
pour un client au moins).

Envoi de messages
^^^^^^^^^^^^^^^^^

NB: pour un email avec PJ, le délégué qui sert d'éditeur d'email compose le 
mail entier, qui est comme un fichier ? Oubien le composeur d'email envoie 
plusieurs flux et c'est le transporteur SMTP qui se charge de composer un 
email ?

La deuxième solution semble inévitable car certains transport nécessiteront 
plusieurs flux (par exemple flux et audio). Donc un message sortant est 
composé de plusieurs fichiers ; tout comme un message entrant d'ailleurs.

Mais on préfère imposer qu'un message soit un fichier.
Donc, pour envoyer un email multipart le délégué doit composer un message 
multipart à partir des morceaux qu'on lui donne. Pour une visio on doit 
encoder le son et l'image dans un conteneur unique (par exemple OGG ou MPEG).


Réception de messages
^^^^^^^^^^^^^^^^^^^^^

Lorsqu'un message est reçu par un connecteur, celui-ci fabrique un header, 
contenant certaines données obligatoires comme par exemple le type de message.  
Puis, il fournit ce header et le flux au mdird, qui :

- détermine les répertoires de destination du message ;
- éventuellement, crée ces répertoires et notifie les clients ;
- commence la copie de ce flux dans le répertoire de stockage et lie ce 
  fichier dans les répertoires destination, en mettant à jour le journal de 
chacun de ces répertoires ;
- notifie les clients de la modification des répertoires destination.

Remarque : le flux transmis au mdird n'est pas nécessairement le flux reçu, 
mais c'est le flux sous la forme que l'on veut le stoquer. Par exemple, pour 
un mail, le connecteur transforme un email en autant de messages qu'il y a de 
pièces jointes. Pour l'IM, chaque message deviens un fichier. Etc.

La seule notification existante est globale et non pas propre à un répertoire 
particulier du mdir. Elle indique seulement que tel ensemble de répertoires 
n'est probablement plus à jour (sauf si le client à resynchronisé 
indépendamment).  Le client doit alors, s'il le souhaite, resynchroniser ce(s) 
répertoire(s) pour découvrir les nouveautées.

Le format de notification est le suivant : chemin du répertoire modifié.

Une fois mis à jour le listing des répertoires, le client peut procéder au 
download du nouveau message oubien se contenter de mémoriser l'info pour plus 
tard ; ce choix est fait par répertoire oubien globalement.

Lorsqu'un nouveau message est downloadé le browser doit choisir :

- a quel programme externe livrer ce message ;
- et en fonction de cela, s'il doit le stoquer dans un fichier ou un fifo ;

Ceci est déterminé par les headers en fonction d'une configuration locale 
similaire, voire identique, à celle des mime-types.

A ce programme externe il n'est fourni que le chemin du message dans le cache 
et pas les répertoires dans lequel des liens sont ajoutés. Le classement en 
répertoire sert au classement, pas au choix des applications externes 
auxquelles sont délégués les messages.


Architecture (serveur)
~~~~~~~~~~~~~~~~~~~~~~

Le serveur se compose, à l'entrée, d'une myriade de connecteurs. L'interface 
entre ceux-ci et le mdir se limite à :

- ajouter une URL et des headers au mdir (sans préciser exactement où, c'est 
  au mdird d'en décider) ;
- de connaître le statut de disponibilité d'un utilisateur ;

Chaque connecteur écrit ses fichiers et génère ses MID, et donne chaque MID 
accompagné des headers au démon du mdir (mdird) qui ajoute le message au mdir 
en tenant compte du journal et en enregistrant les headers.

Tout ceci implique d'adjoindre aux clients classiques du code pour 
l'interfacer avec scambio.

Ensuite, il faut un serveur http permettant de lire et d'écrire le mstore 
(réfléchir à la confidentialité).

Il faut aussi mdird, le programme qui gère le mdir et centralise les 
connections aux clients (et donc, gère les disponibilités).

Utiliser donc un protocole réseau entre connecteurs et mdird, du genre HTTP 
POST avec comme contenu les headers et url du message, oubien encore plus 
simple une connection avec un flux continu de blocs "URL+headers" similaire à 
celui employé pour la synchronisation des répertoires. Il faut aussi, par 
ailleurs, pouvoir interroger le status d'un utilisateurs.

Voir les docs spécifiques aux connecteurs et à mdird pour plus de détails.

Architecture (client)
~~~~~~~~~~~~~~~~~~~~~

Le client est le seul programme qui tourne en permanence. Il ne traite aucune 
forme de message lui même. Il communique avec les délégués uniquement par 
fichiers, en réception comme en création : les délégués déposent le message à 
transmettre dans le mdir et le browser uploade ces nouveaux messages qu'il 
découvre de lui même (FAM oubien polling des dates de modification des 
répertoires ?).

Le client se compose de :

- un browser de messages (facultatif car le browser de fichiers du système 
  peut faire l'affaire dans une certaine mesure) ;

- un downloader, qui synchronise du serveur vers le client et notifie 
  l'utilisateur de l'arrivée d'un nouveau message et propose de l'ouvrir. S'il 
ne sait pas à qui déléguer le message il peut ouvrir le browser (les deux 
communiquent avec dbus). C'est aussi lui qui se connecte au cannal de 
notifications du serveur, et met à jour le status de disponibilité du client ;

- un uploader, qui scanne le mdir à la recherche de messages à envoyer ;


Compatibilité ascendante
------------------------

Comment permettre d'utiliser des clients traditionnels avec mdird ? Par 
exemple, un client Outlook ?

Rien n'empèche d'implémenter des serveurs IMAP/POP3 par dessus mdird.
Toutes les fonctions ne seront pas rendues mais le mail pourrait fonctionner.


Migrations
----------

Depuis IMAP classique
~~~~~~~~~~~~~~~~~~~~~

Depuis Exchange
~~~~~~~~~~~~~~~


References
----------

+ [[[thumbs]]] http://jens.triq.net/thumbnail-spec/index.html[Thumbnail Managing Standard]
  (idéalement il faudrait seulement un ".thumbnail" par répertoire du cache)
+ [[[meta]]] 
http://freedesktop.org/wiki/Specifications/shared-filemetadata-spec[Specifications/shared-filemetadata-spec]
  (pas très utile)
// vim: syntax=asciidoc
